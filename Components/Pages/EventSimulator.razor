@page "/event-simulator"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using TSG_Commex_Shared.DTOs
@using Pastel
@inject IHttpClientFactory HttpClientFactory
@inject ILogger<EventSimulator> Logger
@inject AuthenticationStateProvider AuthenticationStateProvider
@attribute [Authorize(Roles = "Admin")]
@implements IDisposable

<PageTitle>Event Simulator</PageTitle>

<MudText Typo="Typo.h3" Class="mb-2">üõ∞Ô∏è Event Simulator</MudText>
<MudText Typo="Typo.subtitle1" Class="mb-4">Simulate communication status changes in real-time</MudText>

        <MudGrid>
            <MudItem xs="12" md="6">
                <MudPaper Elevation="2" Class="pa-4">
                    <MudText Typo="Typo.h5" Class="mb-3">Simulate Status Change</MudText>
                    
                    <MudForm @ref="form" @bind-IsValid="@success">
                        
                        <MudSelect T="CommunicationResponse" Label="Select Communication" Required="true" 
                            Value="selectedCommunication"
                            ValueChanged="@(async (CommunicationResponse c) => await OnCommunicationSelected(c))"
                            RequiredError="Please select a communication!"
                            Variant="Variant.Outlined" Class="mb-3"
                            ToStringFunc="@(c => c == null ? "" : $"#{c.Id} - {c.Subject}")">
                            @if (availableCommunications == null)
                            {
                                <MudSelectItem Value="@((CommunicationResponse?)null)" Disabled="true">
                                    Loading communications...
                                </MudSelectItem>
                            }
                            else if (!availableCommunications.Any())
                            {
                                <MudSelectItem Value="@((CommunicationResponse?)null)" Disabled="true">
                                    No communications found
                                </MudSelectItem>
                            }
                            else
                            {
                                @foreach (var comm in availableCommunications)
                                {
                                    <MudSelectItem Value="@comm">
                                        <div class="d-flex align-center justify-space-between">
                                            <div>
                                                <MudText Typo="Typo.body2">@comm.Subject</MudText>
                                                <MudText Typo="Typo.caption">Type: @comm.TypeCode | Status: @comm.CurrentStatus</MudText>
                                            </div>
                                        </div>
                                    </MudSelectItem>
                                }
                            }
                        </MudSelect>
                        
                        <MudSelect T="string" Label="Select Event" Required="true" 
                            @bind-Value="selectedEvent" 
                            RequiredError="Please select an event!"
                            Variant="Variant.Outlined" Class="mb-3">
                            @foreach (var evt in GetAvailableEvents())
                            {
                                <MudSelectItem Value="@evt.EventName">
                                    <div class="d-flex align-center">
                                        <MudChip T="string" Size="Size.Small" Color="@GetEventColor(evt.EventName)" Class="mr-2">
                                            @evt.EventName
                                        </MudChip>
                                        <MudText Typo="Typo.caption">‚Üí @evt.ResultingStatus</MudText>
                                    </div>
                                </MudSelectItem>
                            }
                        </MudSelect>
                        
                        <MudTextField T="string" Label="Notes (Optional)" 
                            @bind-Value="notes" 
                            Lines="3" Variant="Variant.Outlined" Class="mb-4" />
                        
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" 
                            Disabled="@(!success || isProcessing)" 
                            OnClick="SimulateStatusChange" FullWidth="true">
                            @if (isProcessing)
                            {
                                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                                <MudText Class="ms-2">Sending Event...</MudText>
                            }
                            else
                            {
                                <MudText>Send Status Change Event</MudText>
                            }
                        </MudButton>
                    </MudForm>
                    
                    @if (!string.IsNullOrEmpty(resultMessage))
                    {
                        <MudAlert Severity="@(isError ? Severity.Error : Severity.Success)" Class="mt-3">
                            @resultMessage
                        </MudAlert>
                    }
                </MudPaper>
            </MudItem>
            
            <MudItem xs="12" md="6">
                <MudPaper Elevation="2" Class="pa-4">
                    <div class="d-flex justify-space-between align-center mb-3">
                        <MudText Typo="Typo.h5">Event History</MudText>
                        <MudSwitch Value="autoRefresh" Color="Color.Primary" Label="Auto-refresh" 
                                   ValueChanged="@(async (bool value) => await ToggleAutoRefresh(value))" />
                    </div>
                    
                    @if (eventHistory.Any())
                    {
                        <MudTimeline>
                            @foreach (var evt in eventHistory.Take(5))
                            {
                                <MudTimelineItem Color="@(evt.Success ? Color.Success : Color.Error)" Size="Size.Small">
                                    <ItemContent>
                                        <MudText Typo="Typo.subtitle2">@evt.CommunicationSubject</MudText>
                                        <MudText Typo="Typo.body2">Event: @evt.EventName ‚Üí @evt.NewStatus</MudText>
                                        <MudText Typo="Typo.caption">@evt.Timestamp.ToString("MM/dd/yyyy hh:mm:ss tt")</MudText>
                                        @if (!string.IsNullOrEmpty(evt.Notes))
                                        {
                                            <MudText Typo="Typo.caption" Class="font-italic">@evt.Notes</MudText>
                                        }
                                    </ItemContent>
                                </MudTimelineItem>
                            }
                        </MudTimeline>
                        
                        <MudText Typo="Typo.caption" Class="mt-3" Align="Align.Center">
                            Showing last @Math.Min(5, eventHistory.Count) of @eventHistory.Count events
                        </MudText>
                    }
                    else
                    {
                        <MudAlert Severity="Severity.Info">
                            No events sent yet. Use the form to simulate your first event!
                        </MudAlert>
                    }
                </MudPaper>
            </MudItem>
        </MudGrid>
        
        <MudPaper Elevation="2" Class="pa-4 mt-4">
            <MudText Typo="Typo.h5" Class="mb-3">Quick Test</MudText>
            <MudText Typo="Typo.body1" Class="mb-3">
                Use this button to quickly test the event system with predefined values.
            </MudText>
            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" 
                OnClick="QuickTest" Disabled="@isProcessing">
                Send Test Event
            </MudButton>
        </MudPaper>

@code {
    private MudForm form = null!;
    private bool success;
    private bool isProcessing = false;
    private bool isError = false;
    private string? resultMessage;
    
    // Form fields
    private IEnumerable<CommunicationResponse>? availableCommunications;
    private CommunicationResponse? selectedCommunication;
    private string selectedEvent = "";
    private string notes = "";
    private List<CommunicationTypeStatusResponse>? availableStatuses;
    
    // Event history
    private List<EventHistoryItem> eventHistory = new();
    
    // Auto-refresh timer
    private System.Threading.Timer? refreshTimer;
    private bool autoRefresh = false;
    
    protected override async Task OnInitializedAsync()
    {
        await LoadCommunications();
        // LoadRecentEvents now uses the already loaded communications
        await LoadRecentEvents();
    }
    
    private async Task OnCommunicationSelected(CommunicationResponse communication)
    {
        selectedCommunication = communication;
        selectedEvent = ""; // Reset event selection
        availableStatuses = null; // Reset statuses
        
        if (communication != null)
        {
            Console.WriteLine("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê".Pastel("#00FF00"));
            Console.WriteLine($"‚îÇ {"üìã Communication Selected".Pastel("#FFFF00")}                                       ‚îÇ");
            Console.WriteLine("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§".Pastel("#00FF00"));
            Console.WriteLine($"‚îÇ {"ID:".Pastel("#00FFFF")}          {communication.Id.ToString().PadRight(54)} ‚îÇ");
            Console.WriteLine($"‚îÇ {"Subject:".Pastel("#00FFFF")}     {(communication.Subject.Length > 54 ? communication.Subject.Substring(0, 51) + "..." : communication.Subject.PadRight(54))} ‚îÇ");
            Console.WriteLine($"‚îÇ {"Type:".Pastel("#00FFFF")}        {communication.TypeCode.PadRight(54)} ‚îÇ");
            Console.WriteLine($"‚îÇ {"Status:".Pastel("#00FFFF")}      {communication.CurrentStatus.PadRight(54)} ‚îÇ");
            Console.WriteLine($"‚îÇ {"Recipient:".Pastel("#00FFFF")}   {(communication.RecipientInfo.Length > 54 ? communication.RecipientInfo.Substring(0, 51) + "..." : communication.RecipientInfo.PadRight(54))} ‚îÇ");
            Console.WriteLine($"‚îÇ {"Created:".Pastel("#00FFFF")}     {communication.CreatedUtc.ToString("yyyy-MM-dd HH:mm:ss").PadRight(54)} ‚îÇ");
            Console.WriteLine("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò".Pastel("#00FF00"));
            
            Logger.LogInformation("Communication selected: {Id} - {Subject}", communication.Id, communication.Subject);
            
            // Load available statuses for this communication type
            await LoadStatusesForType(communication.TypeCode);
            
            // Load actual status history for this communication
            await LoadCommunicationHistory(communication.Id);
        }
    }
    
    private async Task LoadStatusesForType(string typeCode)
    {
        try
        {
            var httpClient = HttpClientFactory.CreateClient("API");
            availableStatuses = await httpClient.GetFromJsonAsync<List<CommunicationTypeStatusResponse>>(
                $"api/communication-types/{typeCode}/statuses");
            
            Console.WriteLine($"{"‚úÖ Loaded".Pastel("#00FF00")} {availableStatuses?.Count ?? 0} {"available statuses for".Pastel("#FFFFFF")} {typeCode.Pastel("#FFFF00")}");
            StateHasChanged(); // Update UI
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading statuses for type {TypeCode}", typeCode);
            Console.WriteLine($"{"‚ùå Error loading statuses:".Pastel("#FF0000")} {ex.Message}");
            availableStatuses = new List<CommunicationTypeStatusResponse>();
        }
    }
    
    private async Task LoadCommunications()
    {
        try
        {
            Logger.LogInformation("Starting to load communications...");
            var httpClient = HttpClientFactory.CreateClient("API");
            availableCommunications = await httpClient.GetFromJsonAsync<IEnumerable<CommunicationResponse>>("api/communications");
            Logger.LogInformation("Loaded {Count} communications", availableCommunications?.Count() ?? 0);
            StateHasChanged(); // Force UI update
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading communications");
            availableCommunications = new List<CommunicationResponse>();
            StateHasChanged(); // Force UI update
        }
    }
    
    private async Task LoadCommunicationHistory(int communicationId)
    {
        try
        {
            Logger.LogInformation("Loading status history for communication {Id}", communicationId);
            var httpClient = HttpClientFactory.CreateClient("API");
            var statusHistory = await httpClient.GetFromJsonAsync<List<CommunicationStatusHistory>>(
                $"api/communications/{communicationId}/status-history");
            
            // Clear existing history and populate with actual data from API
            eventHistory.Clear();
            
            if (statusHistory != null && statusHistory.Any())
            {
                foreach (var history in statusHistory.OrderByDescending(h => h.OccurredUtc))
                {
                    eventHistory.Add(new EventHistoryItem
                    {
                        CommunicationId = history.CommunicationId.ToString(),
                        CommunicationSubject = selectedCommunication?.Subject ?? "Unknown",
                        EventName = history.EventSource ?? "System",
                        NewStatus = history.StatusCode,
                        Notes = history.Notes ?? "",
                        Timestamp = history.OccurredUtc.ToLocalTime(),
                        Success = true
                    });
                }
                
                Logger.LogInformation("Loaded {Count} history records for communication {Id}", 
                    statusHistory.Count, communicationId);
                Console.WriteLine($"{"‚úÖ Loaded".Pastel("#00FF00")} {statusHistory.Count} {"history records".Pastel("#FFFFFF")}");
            }
            else
            {
                Logger.LogInformation("No history found for communication {Id}", communicationId);
                Console.WriteLine($"{"‚ÑπÔ∏è No history found for this communication".Pastel("#FFFF00")}");
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading communication history for {Id}", communicationId);
            Console.WriteLine($"{"‚ùå Error loading history:".Pastel("#FF0000")} {ex.Message}");
        }
    }
    
    private async Task LoadRecentEvents()
    {
        try
        {
            Logger.LogInformation("Loading recent events across all communications");
            
            // Use the already loaded communications instead of fetching again
            if (availableCommunications != null && availableCommunications.Any())
            {
                var httpClient = HttpClientFactory.CreateClient("API");
                eventHistory.Clear();
                
                // For each communication, get its history (limited to recent items)
                foreach (var comm in availableCommunications.Take(10)) // Limit to 10 most recent communications
                {
                    try
                    {
                        var statusHistory = await httpClient.GetFromJsonAsync<List<CommunicationStatusHistory>>(
                            $"api/communications/{comm.Id}/status-history");
                        
                        if (statusHistory != null && statusHistory.Any())
                        {
                            // Add only the most recent events for each communication
                            foreach (var history in statusHistory.OrderByDescending(h => h.OccurredUtc).Take(3))
                            {
                                eventHistory.Add(new EventHistoryItem
                                {
                                    CommunicationId = history.CommunicationId.ToString(),
                                    CommunicationSubject = comm.Subject,
                                    EventName = history.EventSource ?? "System",
                                    NewStatus = history.StatusCode,
                                    Notes = history.Notes ?? "",
                                    Timestamp = history.OccurredUtc.ToLocalTime(),
                                    Success = true
                                });
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogWarning(ex, "Failed to load history for communication {Id}", comm.Id);
                    }
                }
                
                // Sort all events by timestamp descending
                eventHistory = eventHistory.OrderByDescending(e => e.Timestamp).Take(20).ToList();
                
                Logger.LogInformation("Loaded {Count} recent events", eventHistory.Count);
                StateHasChanged();
            }
            else
            {
                Logger.LogInformation("No communications available to load events from");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading recent events");
            // Don't clear history on error, keep whatever we have
        }
    }
    
    
    private List<EventOption> GetAvailableEvents()
    {
        if (selectedCommunication == null || availableStatuses == null)
            return new List<EventOption>();
            
        // Map statuses to events dynamically based on API response
        return availableStatuses.Select(status => 
        {
            // Generate event name based on type code and status
            var eventPrefix = selectedCommunication.TypeCode.ToUpper() switch
            {
                "EOB" => "EOB",
                "EOP" => "EOP",
                "ID_CARD" => "IdCard",
                _ => "Document"
            };
            
            var eventSuffix = status.StatusCode switch
            {
                "Created" => "Created",
                "ReadyForRelease" => "Approved",
                "Released" => "Released",
                "QueuedForPrinting" => "Queued",
                "Printed" => "Printed",
                "Inserted" => "Inserted",
                "Shipped" => "Shipped",
                "Delivered" => "Delivered",
                "Failed" => "Failed",
                _ => status.StatusCode
            };
            
            return new EventOption($"{eventPrefix}{eventSuffix}", status.StatusCode);
        }).ToList();
    }
    
    private async Task SimulateStatusChange()
    {
        isProcessing = true;
        isError = false;
        resultMessage = null;
        
        try
        {
            var httpClient = HttpClientFactory.CreateClient("API");
            
            // Find the resulting status from the selected event
            var eventOption = GetAvailableEvents().FirstOrDefault(e => e.EventName == selectedEvent);
            if (eventOption == null || selectedCommunication == null)
            {
                isError = true;
                resultMessage = "‚ùå Invalid event or communication selection";
                return;
            }
            
            var request = new
            {
                CommunicationId = selectedCommunication.Id.ToString(),
                NewStatus = eventOption.ResultingStatus,
                Notes = string.IsNullOrWhiteSpace(notes) ? $"Event: {selectedEvent}" : $"Event: {selectedEvent} - {notes}"
            };
            
            var response = await httpClient.PostAsJsonAsync("api/events/simulate-status-change", request);
            
            if (response.IsSuccessStatusCode)
            {
                resultMessage = $"‚úÖ Event '{selectedEvent}' published successfully! Communication #{selectedCommunication.Id} status will change to {eventOption.ResultingStatus}";
                
                // Log before clearing
                Logger.LogInformation("Successfully sent event {Event} for communication {CommunicationId}", selectedEvent, selectedCommunication.Id);
                
                // Store the communication ID before clearing
                var communicationId = selectedCommunication.Id;
                
                // Clear form
                selectedCommunication = null;
                selectedEvent = "";
                notes = "";
                await form.ResetAsync();
                
                // Force immediate UI update to show the success message
                StateHasChanged();
                
                // Small delay to let the backend process the event
                await Task.Delay(500);
                
                // Reload communications to reflect changes
                await LoadCommunications();
                
                // Reload the history to show the new event
                await LoadCommunicationHistory(communicationId);
                
                // Force another UI update with the refreshed data
                StateHasChanged();
            }
            else
            {
                isError = true;
                resultMessage = $"‚ùå Failed to publish event: {response.StatusCode}";
                Logger.LogError("Failed to send event: {StatusCode}", response.StatusCode);
            }
        }
        catch (Exception ex)
        {
            isError = true;
            resultMessage = $"‚ùå Error: {ex.Message}";
            Logger.LogError(ex, "Error sending event");
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }
    }
    
    private async Task QuickTest()
    {
        isProcessing = true;
        isError = false;
        resultMessage = null;
        
        try
        {
            var httpClient = HttpClientFactory.CreateClient("API");
            var response = await httpClient.GetAsync("api/events/test");
            
            if (response.IsSuccessStatusCode)
            {
                resultMessage = "‚úÖ Test event sent successfully! Check your backend logs for confirmation.";
                
                eventHistory.Insert(0, new EventHistoryItem
                {
                    CommunicationId = "1",
                    NewStatus = "Printed",
                    Notes = "Quick test event",
                    Timestamp = DateTime.Now,
                    Success = true
                });
            }
            else
            {
                isError = true;
                resultMessage = $"‚ùå Test failed: {response.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            isError = true;
            resultMessage = $"‚ùå Error: {ex.Message}";
            Logger.LogError(ex, "Error sending test event");
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }
    }
    
    private Color GetEventColor(string eventName)
    {
        return eventName.ToLower() switch
        {
            var e when e.Contains("created") || e.Contains("requested") => Color.Info,
            var e when e.Contains("approved") || e.Contains("released") => Color.Warning,
            var e when e.Contains("printed") || e.Contains("queued") => Color.Primary,
            var e when e.Contains("shipped") => Color.Secondary,
            var e when e.Contains("delivered") => Color.Success,
            var e when e.Contains("failed") => Color.Error,
            _ => Color.Default
        };
    }
    
    // Helper classes
    private Task ToggleAutoRefresh(bool value)
    {
        autoRefresh = value;
        
        if (autoRefresh)
        {
            // Create a timer that refreshes every 5 seconds
            refreshTimer = new System.Threading.Timer(async _ =>
            {
                await InvokeAsync(async () =>
                {
                    await LoadCommunications();
                    if (selectedCommunication != null)
                    {
                        await LoadCommunicationHistory(selectedCommunication.Id);
                    }
                    else
                    {
                        await LoadRecentEvents();
                    }
                    StateHasChanged();
                });
            }, null, TimeSpan.Zero, TimeSpan.FromSeconds(5));
            
            Logger.LogInformation("Auto-refresh enabled");
        }
        else
        {
            // Stop the timer
            refreshTimer?.Dispose();
            refreshTimer = null;
            Logger.LogInformation("Auto-refresh disabled");
        }
        
        return Task.CompletedTask;
    }
    
    public void Dispose()
    {
        refreshTimer?.Dispose();
    }
    
    private record EventOption(string EventName, string ResultingStatus);
    
    private class EventHistoryItem
    {
        public string CommunicationId { get; set; } = "";
        public string CommunicationSubject { get; set; } = "";
        public string EventName { get; set; } = "";
        public string NewStatus { get; set; } = "";
        public string? Notes { get; set; }
        public DateTime Timestamp { get; set; }
        public bool Success { get; set; }
    }
}